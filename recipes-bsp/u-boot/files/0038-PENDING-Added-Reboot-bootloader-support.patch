From d712e6197084f87b85867730a007c86591a6316e Mon Sep 17 00:00:00 2001
From: Aswin Murugan <quic_aswinm@quicinc.com>
Date: Wed, 19 Mar 2025 11:56:12 +0530
Subject: [PATCH] PENDING: Added Reboot bootloader support

Added support to stop at fastboot when 'reboot bootloader'
is given in Linux console.

Signed-off-by: Aswin Murugan <quic_aswinm@quicinc.com>
Upstream-Status: Pending
---
 cmd/bootqli.c           | 29 +++++++++++++++++++++++++++++
 drivers/spmi/spmi-msm.c |  5 +++++
 2 files changed, 34 insertions(+)

diff --git a/cmd/bootqli.c b/cmd/bootqli.c
index 29d688c951..b5eec5b186 100644
--- a/cmd/bootqli.c
+++ b/cmd/bootqli.c
@@ -9,6 +9,7 @@
 #include <part.h>
 #include <scsi.h>
 #include <stdlib.h>
+#include <power/pmic.h>
 
 #ifdef CONFIG_SYS_MAXARGS
 #define MAX_BOOT_ARGS_SIZE      CONFIG_SYS_MAXARGS
@@ -16,6 +17,11 @@
 #define MAX_BOOT_ARGS_SIZE      64
 #endif
 
+#define FASTBOOT_MODE 0x2
+#define SDAM02_BASE_ADDR 0x7100
+#define PON_RESET_REG_ADDR (SDAM02_BASE_ADDR + 0x48)
+#define REBOOT_MODE_MASK 0xFE
+
 const char *boot_config;
 
 struct ufs_info {
@@ -23,6 +29,7 @@ struct ufs_info {
 	struct disk_partition part;
 };
 
+static int check_fastboot_mode(void);
 static int boot_ufs(void);
 static int config_select(void);
 static int set_bootargs(void);
@@ -32,6 +39,7 @@ static int do_bootqli(struct cmd_tbl *cmdtp, int flag, int argc,
 
 typedef int (*state_func_t)(void);
 static const state_func_t state_sequence[] = {
+	check_fastboot_mode,
 	boot_ufs,
 	config_select,
 	set_bootargs,
@@ -98,6 +106,27 @@ static int boot_kernel(void)
 	return run_command(boot_cmd, 0);
 }
 
+static int check_fastboot_mode(void)
+{
+#ifdef CONFIG_DM_PMIC
+	struct udevice *dev;
+	int ret, reboot_reason, reg_val;
+
+	ret = pmic_get("pmic@0", &dev);
+	if (ret)
+		return ret;
+	reg_val = pmic_reg_read(dev, PON_RESET_REG_ADDR);
+	reboot_reason = (reg_val & REBOOT_MODE_MASK) >> 1;
+	if (reboot_reason == FASTBOOT_MODE) {
+		reg_val &= ~(REBOOT_MODE_MASK);
+		pmic_reg_write(dev, PON_RESET_REG_ADDR, (uint)reg_val);
+		ret = run_command("fastboot usb 0", 0);
+	}
+
+	return ret;
+#endif
+}
+
 static int do_bootqli(struct cmd_tbl *cmdtp, int flag, int argc,
 		      char *const argv[])
 {
diff --git a/drivers/spmi/spmi-msm.c b/drivers/spmi/spmi-msm.c
index 5cc5a9e654..3933a0172d 100644
--- a/drivers/spmi/spmi-msm.c
+++ b/drivers/spmi/spmi-msm.c
@@ -62,6 +62,8 @@ DECLARE_GLOBAL_DATA_PTR;
 #define SPMI_CHANNEL_READ_ONLY	BIT(31)
 #define SPMI_CHANNEL_MASK	0xffff
 
+#define SDAM02_REBOOT_MODE_PID 0x71
+
 enum arb_ver {
 	V1 = 1,
 	V2,
@@ -299,6 +301,9 @@ static int msm_spmi_probe(struct udevice *dev)
 
 		priv->channel_map[slave_id][pid] = i;
 
+		/* Skip setting readonly flag for SDAM02 reboot reason pid*/
+		if (slave_id == 0 && pid == SDAM02_REBOOT_MODE_PID)
+			continue;
 		/* Mark channels read-only when from different owner */
 		if (priv->arb_ver == V5 || priv->arb_ver == V7) {
 			uint32_t cnfg = readl(priv->spmi_cnfg + ARB_CHANNEL_OFFSET(i));
-- 
2.34.1

