From c7490ce84f5a0495502f2ffb99b835cdff38b4fe Mon Sep 17 00:00:00 2001
From: Aswin Murugan <quic_aswinm@quicinc.com>
Date: Thu, 6 Feb 2025 15:10:18 +0530
Subject: [PATCH] PENDING: mach-snapdragon: Support for boot command bootqli

Added support for boot command bootqli to boot from memory

Signed-off-by: Aswin Murugan <quic_aswinm@quicinc.com>
Upstream-Status: Pending
---
 board/qualcomm/default.env |   2 +-
 cmd/Kconfig                |  18 +++++++
 cmd/Makefile               |   1 +
 cmd/bootqli.c              | 102 +++++++++++++++++++++++++++++++++++++
 configs/qcs9100_defconfig  |   2 +
 drivers/scsi/scsi-uclass.c |  30 +++++++++++
 include/scsi.h             |  11 ++++
 7 files changed, 165 insertions(+), 1 deletion(-)
 create mode 100644 cmd/bootqli.c

diff --git a/board/qualcomm/default.env b/board/qualcomm/default.env
index 534a56abd3..742136d0a5 100644
--- a/board/qualcomm/default.env
+++ b/board/qualcomm/default.env
@@ -9,4 +9,4 @@ bootmenu_0=Boot first available device=run do_boot
 bootmenu_1=Enable fastboot mode=run fastboot
 bootmenu_2=Reset device=reset
 menucmd=bootmenu
-bootcmd=scsi device 0; scsi read 0xd3500000 0x6 0x4000; bootm 0xd3500000
+bootcmd=bootqli
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 1d7ddb4ed3..8494934bc4 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -347,6 +347,24 @@ config CMD_BOOTI
 	help
 	  Boot an AArch64 Linux Kernel image from memory.
 
+config CMD_BOOTQLI
+	bool "bootqli"
+	depends on CMD_BOOTM
+	default y
+	help
+	  Boot an AArch64 Linux Kernel image from memory.
+
+if CMD_BOOTQLI
+
+config CMD_BOOTQLI_MAP_SIZE
+	hex "Memory size"
+	depends on CMD_BOOTQLI
+	default "0x4000"
+        help
+          Memory size to load an AArch64 Linux Kernel image from memory.
+
+endif
+
 config BOOTM_LINUX
 	bool "Support booting Linux OS images"
 	depends on CMD_BOOTM || CMD_BOOTZ || CMD_BOOTI
diff --git a/cmd/Makefile b/cmd/Makefile
index d1f369deec..0f9506fee7 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_CMD_BOOTMENU) += bootmenu.o
 obj-$(CONFIG_CMD_BOOTSTAGE) += bootstage.o
 obj-$(CONFIG_CMD_BOOTZ) += bootz.o
 obj-$(CONFIG_CMD_BOOTI) += booti.o
+obj-$(CONFIG_CMD_BOOTQLI) += bootqli.o
 obj-$(CONFIG_CMD_BTRFS) += btrfs.o
 obj-$(CONFIG_CMD_BUTTON) += button.o
 obj-$(CONFIG_CMD_CAT) += cat.o
diff --git a/cmd/bootqli.c b/cmd/bootqli.c
new file mode 100644
index 0000000000..33ca6170f1
--- /dev/null
+++ b/cmd/bootqli.c
@@ -0,0 +1,102 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2025, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include <bootm.h>
+#include <blk.h>
+#include <command.h>
+#include <part.h>
+#include <scsi.h>
+
+#ifdef CONFIG_SYS_MAXARGS
+#define MAX_BOOT_ARGS_SIZE      CONFIG_SYS_MAXARGS
+#elif
+#define MAX_BOOT_ARGS_SIZE      64
+#endif
+
+const char *boot_config;
+
+struct ufs_info {
+	struct blk_desc *blk;
+	struct disk_partition part;
+};
+
+static int boot_ufs(void);
+static int config_select(void);
+static int set_bootargs(void);
+static int boot_kernel(void);
+static int do_bootqli(struct cmd_tbl *cmdtp, int flag, int argc,
+		      char *const argv[]);
+
+typedef int (*state_func_t)(void);
+static const state_func_t state_sequence[] = {
+	boot_ufs,
+	config_select,
+	set_bootargs,
+	boot_kernel,
+	NULL
+};
+
+static int boot_ufs(void)
+{
+	struct ufs_info info = {0};
+
+	if (scsi_get_blk("boot_a", &info.blk, &info.part))
+		return -EIO;
+
+	blk_dread(info.blk, info.part.start, (ulong)CONFIG_CMD_BOOTQLI_MAP_SIZE,
+		  (void *)CONFIG_SYS_LOAD_ADDR);
+
+	return 0;
+}
+
+static int config_select(void)
+{
+	return 0;
+}
+
+static int set_bootargs(void)
+{
+	return 0;
+}
+
+static int boot_kernel(void)
+{
+	char boot_cmd[MAX_BOOT_ARGS_SIZE];
+
+	if (boot_config)
+		snprintf(boot_cmd, sizeof(boot_cmd),
+			 "bootm 0x%lx#%s\n",
+			 CONFIG_SYS_LOAD_ADDR, boot_config);
+	else
+		snprintf(boot_cmd, sizeof(boot_cmd),
+			 "bootm 0x%lx\n", CONFIG_SYS_LOAD_ADDR);
+
+	return run_command(boot_cmd, 0);
+}
+
+static int do_bootqli(struct cmd_tbl *cmdtp, int flag, int argc,
+		      char *const argv[])
+{
+	int ret, state;
+	const state_func_t *state_sequence_ptr;
+
+	for (state_sequence_ptr = state_sequence, state = 1;
+	     *state_sequence_ptr;
+	     ++state_sequence_ptr, state++) {
+		ret = (*state_sequence_ptr)();
+		if (ret) {
+			log_err("Failed at state %d\n", state);
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	bootqli, 1, 0, do_bootqli,
+	"bootqli from flash device",
+	"bootqli - Load image(s) and boots the kernel\n"
+	);
diff --git a/configs/qcs9100_defconfig b/configs/qcs9100_defconfig
index bbee62f417..1cb23dee27 100644
--- a/configs/qcs9100_defconfig
+++ b/configs/qcs9100_defconfig
@@ -18,6 +18,8 @@ CONFIG_DEBUG_UART_CLOCK=14745600
 CONFIG_TEXT_BASE=0xaf000000
 CONFIG_REMAKE_ELF=y
 CONFIG_ENV_IS_IN_UFS=y
+CONFIG_SYS_LOAD_ADDR=0xD3500000
+CONFIG_CMD_BOOTQLI=y
 
 CONFIG_DEFAULT_DEVICE_TREE="qcom/qcs9100-ride-r3"
 # CONFIG_ENV_IS_DEFAULT is not set
diff --git a/drivers/scsi/scsi-uclass.c b/drivers/scsi/scsi-uclass.c
index 1ee8236c05..c2e34082bc 100644
--- a/drivers/scsi/scsi-uclass.c
+++ b/drivers/scsi/scsi-uclass.c
@@ -10,7 +10,9 @@
 
 #define LOG_CATEGORY UCLASS_SCSI
 
+#include <blk.h>
 #include <dm.h>
+#include <part.h>
 #include <scsi.h>
 
 int scsi_exec(struct udevice *dev, struct scsi_cmd *pccb)
@@ -23,6 +25,34 @@ int scsi_exec(struct udevice *dev, struct scsi_cmd *pccb)
 	return ops->exec(dev, pccb);
 }
 
+int scsi_get_blk(const char *partition_name,
+		 struct blk_desc **blk_desc_ptr,
+		 struct disk_partition *part_info_ptr)
+{
+	static int is_scsi_scanned;
+	struct blk_desc *blk;
+	int i, ret;
+
+	if (!is_scsi_scanned) {
+		scsi_scan(false /* no verbose */);
+		is_scsi_scanned = 1;
+	}
+
+	for (i = 0; i < blk_find_max_devnum(UCLASS_SCSI) + 1; i++) {
+		ret = blk_get_desc(UCLASS_SCSI, i, &blk);
+		if (ret)
+			continue;
+
+		ret = part_get_info_by_name(blk, partition_name, part_info_ptr);
+		if (ret > 0) {
+			*blk_desc_ptr = blk;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
 int scsi_bus_reset(struct udevice *dev)
 {
 	struct scsi_ops *ops = scsi_get_ops(dev);
diff --git a/include/scsi.h b/include/scsi.h
index b18ae37b86..dea99ebf2a 100644
--- a/include/scsi.h
+++ b/include/scsi.h
@@ -349,6 +349,17 @@ int scsi_scan(bool verbose);
  */
 int scsi_scan_dev(struct udevice *dev, bool verbose);
 
+/**
+ * scsi_get_blk() - Provides SCSI partition information.
+ *
+ * @partition_name: Partition name for fetching its info
+ * @blk_desc_ptr:   Provides the blk descriptor
+ * @part_info_ptr:  Provides partition info
+ */
+int scsi_get_blk(const char *partition_name,
+		 struct blk_desc **blk_desc_ptr,
+		 struct disk_partition *part_info_ptr);
+
 #define SCSI_IDENTIFY					0xC0  /* not used */
 
 /* Hardware errors  */
-- 
2.34.1

