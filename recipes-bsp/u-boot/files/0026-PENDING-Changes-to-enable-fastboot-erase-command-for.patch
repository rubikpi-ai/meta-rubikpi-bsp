From 30b69e2549ad57998faf065fcb4ad47bc4376e6a Mon Sep 17 00:00:00 2001
From: Balaji Selvanathan <quic_bselvana@quicinc.com>
Date: Fri, 7 Feb 2025 09:49:16 +0530
Subject: [PATCH] PENDING: Changes to enable fastboot erase command for Lemans
 in U-Boot

Changes to enable fastboot erase command and changes in fastboot flash/write and erase to detect partitions on any UFS device (without specifying device number in fastboot command) for Lemans in U-Boot

Signed-off-by: Balaji Selvanathan <quic_bselvana@quicinc.com>
Upstream-Status: Pending
---
 drivers/fastboot/fb_mmc.c | 70 ++++++++++++++++++++++++++++++++-------
 1 file changed, 58 insertions(+), 12 deletions(-)

diff --git a/drivers/fastboot/fb_mmc.c b/drivers/fastboot/fb_mmc.c
index 3c6272bb3d..9572d99704 100644
--- a/drivers/fastboot/fb_mmc.c
+++ b/drivers/fastboot/fb_mmc.c
@@ -17,6 +17,7 @@
 #include <div64.h>
 #include <linux/compat.h>
 #include <android_image.h>
+#include <scsi.h>
 
 #define BOOT_PARTITION_NAME "boot"
 
@@ -498,6 +499,43 @@ int fastboot_mmc_get_part_info(const char *part_name,
 	return ret;
 }
 
+int fastboot_ufs_get_part_info(const char *part_name,
+			       struct blk_desc **dev_desc,
+			       struct disk_partition *part_info, char *response)
+{
+	int ret;
+
+	if (!part_name || !strcmp(part_name, "")) {
+		fastboot_fail("partition not given", response);
+		return -ENOENT;
+	}
+
+	ret = scsi_get_blk(part_name, dev_desc, part_info);
+
+	if (ret < 0) {
+		switch (ret) {
+		case -ENOSYS:
+		case -EINVAL:
+			fastboot_fail("invalid partition or device", response);
+			break;
+		case -ENODEV:
+			fastboot_fail("no such device", response);
+			break;
+		case -ENOENT:
+			fastboot_fail("no such partition", response);
+			break;
+		case -EPROTONOSUPPORT:
+			fastboot_fail("unknown partition table type", response);
+			break;
+		default:
+			fastboot_fail("unanticipated error", response);
+			break;
+		}
+	}
+
+	return ret;
+}
+
 static struct blk_desc *fastboot_mmc_get_dev(char *response)
 {
 	struct blk_desc *ret = blk_get_dev(fb_flash_str, fb_flash_dev);
@@ -616,10 +654,15 @@ void fastboot_mmc_flash_write(const char *cmd, void *download_buffer,
 	}
 #endif
 
+#ifdef CONFIG_FASTBOOT_FLASH_UFS
+	if (!info.name[0] &&
+	    fastboot_ufs_get_part_info(cmd, &dev_desc, &info, response) < 0)
+		return;
+#else
 	if (!info.name[0] &&
 	    fastboot_mmc_get_part_info(cmd, &dev_desc, &info, response) < 0)
 		return;
-
+#endif
 	if (is_sparse_image(download_buffer)) {
 		struct fb_mmc_sparse sparse_priv;
 		struct sparse_storage sparse;
@@ -656,10 +699,11 @@ void fastboot_mmc_flash_write(const char *cmd, void *download_buffer,
  */
 void fastboot_mmc_erase(const char *cmd, char *response)
 {
-#ifdef CONFIG_FASTBOOT_FLASH_MMC
 	struct blk_desc *dev_desc;
 	struct disk_partition info;
-	lbaint_t blks, blks_start, blks_size, grp_size;
+	lbaint_t blks, blks_start, blks_size;
+
+#ifdef CONFIG_FASTBOOT_FLASH_MMC
 	struct mmc *mmc = find_mmc_device(fb_flash_dev);
 
 #ifdef CONFIG_FASTBOOT_MMC_BOOT_SUPPORT
@@ -693,18 +737,21 @@ void fastboot_mmc_erase(const char *cmd, char *response)
 		return;
 	}
 #endif
+#endif
 
+#ifdef CONFIG_FASTBOOT_FLASH_UFS
+	if (fastboot_ufs_get_part_info(cmd, &dev_desc, &info, response) < 0)
+		return;
+#else
 	if (fastboot_mmc_get_part_info(cmd, &dev_desc, &info, response) < 0)
 		return;
+#endif
 
-	/* Align blocks to erase group size to avoid erasing other partitions */
-	grp_size = mmc->erase_grp_size;
-	blks_start = (info.start + grp_size - 1) & ~(grp_size - 1);
-	if (info.size >= grp_size)
-		blks_size = (info.size - (blks_start - info.start)) &
-				(~(grp_size - 1));
-	else
-		blks_size = 0;
+#ifdef CONFIG_FASTBOOT_FLASH_UFS
+	blks_start = info.start;
+	blks_size = info.size;
+#else
+#endif
 
 	printf("Erasing blocks " LBAFU " to " LBAFU " due to alignment\n",
 	       blks_start, blks_start + blks_size);
@@ -719,7 +766,6 @@ void fastboot_mmc_erase(const char *cmd, char *response)
 
 	printf("........ erased " LBAFU " bytes from '%s'\n",
 	       blks_size * info.blksz, cmd);
-#endif
 
 	fastboot_okay(NULL, response);
 }
-- 
2.34.1

