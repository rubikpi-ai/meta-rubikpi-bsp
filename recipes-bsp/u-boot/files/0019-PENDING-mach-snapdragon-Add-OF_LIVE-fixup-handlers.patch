From f154305a34942cf57793c707b4da34196d98d8ef Mon Sep 17 00:00:00 2001
From: Aswin Murugan <quic_aswinm@quicinc.com>
Date: Thu, 30 Jan 2025 16:50:08 +0530
Subject: [PATCH 19/20] PENDING: mach-snapdragon: Add OF_LIVE fixup handlers

Support for run time fdt fixup using OF_LIVE

Signed-off-by: Aswin Murugan <quic_aswinm@quicinc.com>
Upstream-Status: Pending
---
 arch/arm/mach-snapdragon/Kconfig              |   7 +
 arch/arm/mach-snapdragon/Makefile             |   5 +
 arch/arm/mach-snapdragon/chipinfo_def.h       |  90 ++++++
 arch/arm/mach-snapdragon/of_fixup.c           |  83 +++++
 .../mach-snapdragon/qcom_fixup_boardinfo.c    | 226 ++++++++++++++
 arch/arm/mach-snapdragon/qcom_fixup_ddrinfo.c | 136 +++++++++
 .../arm/mach-snapdragon/qcom_fixup_handlers.h |  79 +++++
 .../mach-snapdragon/qcom_fixup_hypervisor.c   | 265 ++++++++++++++++
 .../mach-snapdragon/qcom_fixup_subsetparts.c  | 289 ++++++++++++++++++
 arch/arm/mach-snapdragon/qcom_sa8775p_fixup.c |  23 ++
 10 files changed, 1203 insertions(+)
 create mode 100644 arch/arm/mach-snapdragon/chipinfo_def.h
 create mode 100644 arch/arm/mach-snapdragon/qcom_fixup_boardinfo.c
 create mode 100644 arch/arm/mach-snapdragon/qcom_fixup_ddrinfo.c
 create mode 100644 arch/arm/mach-snapdragon/qcom_fixup_handlers.h
 create mode 100644 arch/arm/mach-snapdragon/qcom_fixup_hypervisor.c
 create mode 100644 arch/arm/mach-snapdragon/qcom_fixup_subsetparts.c
 create mode 100644 arch/arm/mach-snapdragon/qcom_sa8775p_fixup.c

diff --git a/arch/arm/mach-snapdragon/Kconfig b/arch/arm/mach-snapdragon/Kconfig
index 976c0e35fc..62f862f27c 100644
--- a/arch/arm/mach-snapdragon/Kconfig
+++ b/arch/arm/mach-snapdragon/Kconfig
@@ -29,6 +29,13 @@ config SYS_MALLOC_LEN
 config LNX_KRNL_IMG_TEXT_OFFSET_BASE
 	default 0x80000000
 
+config OF_LIVE_SA8775P
+        bool "Enable OF LIVE SA8775P"
+        select OF_LIVE
+        help
+          Say Y here to enable support for OF LIVE fixups
+          on the Snapdragon SA8775 SoC.
+
 config SYS_BOARD
 	string "Snapdragon SoCs based board"
 	help
diff --git a/arch/arm/mach-snapdragon/Makefile b/arch/arm/mach-snapdragon/Makefile
index 343e825c6f..61b1929f70 100644
--- a/arch/arm/mach-snapdragon/Makefile
+++ b/arch/arm/mach-snapdragon/Makefile
@@ -4,4 +4,9 @@
 
 obj-y += board.o
 obj-$(CONFIG_EFI_HAVE_CAPSULE_SUPPORT) += capsule_update.o
+obj-$(CONFIG_OF_LIVE_SA8775P) += qcom_sa8775p_fixup.o
+obj-$(CONFIG_OF_LIVE) += qcom_fixup_boardinfo.o
+obj-$(CONFIG_OF_LIVE) += qcom_fixup_ddrinfo.o
+obj-$(CONFIG_OF_LIVE) += qcom_fixup_hypervisor.o
+obj-$(CONFIG_OF_LIVE) += qcom_fixup_subsetparts.o
 obj-$(CONFIG_OF_LIVE) += of_fixup.o
diff --git a/arch/arm/mach-snapdragon/chipinfo_def.h b/arch/arm/mach-snapdragon/chipinfo_def.h
new file mode 100644
index 0000000000..a4f9bc247f
--- /dev/null
+++ b/arch/arm/mach-snapdragon/chipinfo_def.h
@@ -0,0 +1,90 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Type and enum definitions for the Chip Info driver
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+enum chip_info_result {
+	CHIPINFO_SUCCESS = 0,
+	CHIPINFO_ERROR = -1,
+	CHIPINFO_ERROR_INVALID_PARAMETER = -2,
+	CHIPINFO_ERROR_INSUFFICIENT_MEMORY = -3,
+	CHIPINFO_ERROR_NOT_FOUND = -4,
+	CHIPINFO_ERROR_INTERNAL = -5,
+	CHIPINFO_ERROR_NOT_ALLOWED = -6,
+	CHIPINFO_ERROR_NOT_SUPPORTED = -7,
+	CHIPINFO_ERROR_NOT_INITIALIZED = -8,
+	CHIPINFO_ERROR_OUT_OF_RANGE_PARAMETER = -9,
+	CHIPINFO_ERROR_INVALID_ADDRESS = -10,
+	CHIPINFO_ERROR_INSUFFICIENT_BUFFER_LENGTH = -11,
+};
+
+/**
+ * Supported parts by the chipinfo_get_disabled_features API.
+ * New parts should be appended to this enum (i.e. not inserted)
+ * to preserve backwards compatibility.
+ *
+ * For targets that have multiple instances of a specific part,
+ * a new part with a _N suffix should be added. On these targets,
+ * part enums without the _N suffix are for the 0th instance,
+ * e.g. CHIPINFO_PART_DISPLAY is for MDSS_0 on Makena.
+ */
+enum chip_info_Part_type {
+	CHIPINFO_PART_UNKNOWN = 0,
+	CHIPINFO_PART_GPU = 1,
+	CHIPINFO_PART_VIDEO = 2,
+	CHIPINFO_PART_CAMERA = 3,
+	CHIPINFO_PART_DISPLAY = 4,
+	CHIPINFO_PART_AUDIO = 5,
+	CHIPINFO_PART_MODEM = 6,
+	CHIPINFO_PART_WLAN = 7,
+	CHIPINFO_PART_COMP = 8, // For both CDSP and NSP
+	CHIPINFO_PART_SENSORS = 9,
+	CHIPINFO_PART_NPU = 10,
+	CHIPINFO_PART_SPSS = 11,
+	CHIPINFO_PART_NAV = 12,
+	CHIPINFO_PART_COMPUTE_1 = 13,
+	CHIPINFO_PART_DISPLAY_1 = 14,
+	CHIPINFO_PART_NSP = 15,
+	CHIPINFO_PART_EVA = 16,
+	CHIPINFO_PART_PCIE = 17,
+	CHIPINFO_PART_CPU = 18,
+	CHIPINFO_PART_DDR = 19,
+
+	CHIPINFO_NUM_PARTS,
+	CHIPINFO_PART_32BITS = 0x7FFFFFFF
+};
+
+/**
+ * SKU_IDs logical mapping.
+ * See ChipInfo_GetSKU for more details.
+ */
+enum chip_info_skuid_type {
+	CHIPINFO_SKU_UNKNOWN = 0,
+
+	CHIPINFO_SKU_AA = 0x01,
+	CHIPINFO_SKU_AB = 0x02,
+	CHIPINFO_SKU_AC = 0x03,
+	CHIPINFO_SKU_AD = 0x04,
+	CHIPINFO_SKU_AE = 0x05,
+	CHIPINFO_SKU_AF = 0x06,
+	// Reserved for future use
+
+	CHIPINFO_SKU_Y0 = 0xf1,
+	CHIPINFO_SKU_Y1 = 0xf2,
+	CHIPINFO_SKU_Y2 = 0xf3,
+	CHIPINFO_SKU_Y3 = 0xf4,
+	CHIPINFO_SKU_Y4 = 0xf5,
+	CHIPINFO_SKU_Y5 = 0xf6,
+	CHIPINFO_SKU_Y6 = 0xf7,
+	CHIPINFO_SKU_Y7 = 0xf8,
+	// Reserved for future use
+
+};
+
diff --git a/arch/arm/mach-snapdragon/of_fixup.c b/arch/arm/mach-snapdragon/of_fixup.c
index 55368dd43b..bcbd211bbb 100644
--- a/arch/arm/mach-snapdragon/of_fixup.c
+++ b/arch/arm/mach-snapdragon/of_fixup.c
@@ -26,6 +26,7 @@
 #include <linux/errno.h>
 #include <stdlib.h>
 #include <time.h>
+#include "qcom_fixup_handlers.h"
 
 /* U-Boot only supports USB high-speed mode on Qualcomm platforms with DWC3
  * USB controllers. Rather than requiring source level DT changes, we fix up
@@ -156,11 +157,16 @@ void qcom_of_fixup_nodes(void)
 	time_call(fixup_power_domains);
 }
 
+__weak void fixup_dt_handler(struct fdt_header *fdt_ptr)
+{
+}
+
 int ft_board_setup(void *blob, struct bd_info __maybe_unused *bd)
 {
 	struct fdt_header *fdt = blob;
 	int node;
 
+	fixup_dt_handler(fdt);
 	/* We only want to do this fix-up for the RB1 board, quick return for all others */
 	if (!fdt_node_check_compatible(fdt, 0, "qcom,qrb4210-rb2"))
 		return 0;
@@ -173,3 +179,80 @@ int ft_board_setup(void *blob, struct bd_info __maybe_unused *bd)
 
 	return 0;
 }
+
+int fixup_dt_node(void *fdt_ptr, int node_offset,
+		  const char *property_name,
+		  void *property_value,
+		  enum fdt_fixup_type type)
+{
+	int ret;
+
+	if ((!fdt_ptr || node_offset < 0) ||
+	    (!property_value && type != ADD_SUBNODE))
+		return -1;
+
+	switch (type) {
+	case APPEND_PROP_U32:
+			    fdt_set_totalsize(fdt_ptr,
+					      (fdt_totalsize(fdt_ptr)
+					      + sizeof(struct fdt_property)
+					      + strlen(property_name) + 3
+					      + sizeof(u32)));
+			    ret = fdt_appendprop_u32(fdt_ptr, node_offset,
+						     property_name,
+						     *(u32 *)property_value);
+			    break;
+	case APPEND_PROP_U64:
+			    fdt_set_totalsize(fdt_ptr,
+					      (fdt_totalsize(fdt_ptr)
+					      + sizeof(struct fdt_property)
+					      + strlen(property_name) + 3
+					      + sizeof(u64)));
+			    ret = fdt_appendprop_u64(fdt_ptr, node_offset,
+						     property_name,
+						     *(u64 *)property_value);
+			    break;
+	case SET_PROP_U32:
+			 fdt_set_totalsize(fdt_ptr,
+					   (fdt_totalsize(fdt_ptr)
+					   + sizeof(struct fdt_property)
+					   + strlen(property_name) + 3
+					   + sizeof(u32)));
+			 ret = fdt_setprop_u32(fdt_ptr, node_offset,
+					       property_name,
+					       *(u32 *)property_value);
+			 break;
+	case SET_PROP_U64:
+			 fdt_set_totalsize(fdt_ptr,
+					   (fdt_totalsize(fdt_ptr)
+					   + sizeof(struct fdt_property)
+					   + strlen(property_name) + 3
+					   + sizeof(u64)));
+			 ret = fdt_setprop_u64(fdt_ptr, node_offset,
+					       property_name,
+					       *(u64 *)property_value);
+			 break;
+	case SET_PROP_STRING:
+			    fdt_set_totalsize(fdt_ptr,
+					      (fdt_totalsize(fdt_ptr)
+					      + sizeof(struct fdt_property)
+					      + strlen(property_name) + 3
+					      + strlen((char *)property_value)));
+			    ret = fdt_setprop_string(fdt_ptr, node_offset,
+						     property_name,
+						     (char *)property_value);
+			    break;
+	case ADD_SUBNODE:
+			fdt_set_totalsize(fdt_ptr,
+					  (fdt_totalsize(fdt_ptr)
+					  + sizeof(struct fdt_property)
+					  + strlen(property_name) + 3));
+			ret = fdt_add_subnode(fdt_ptr, node_offset,
+					      property_name);
+			break;
+	default:
+		ret = -1;
+	}
+
+	return ret;
+}
diff --git a/arch/arm/mach-snapdragon/qcom_fixup_boardinfo.c b/arch/arm/mach-snapdragon/qcom_fixup_boardinfo.c
new file mode 100644
index 0000000000..d4304da285
--- /dev/null
+++ b/arch/arm/mach-snapdragon/qcom_fixup_boardinfo.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Board Info FDT Fixup
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ * This file contains code to fix up the device tree blob (DTB) for the board.
+ * It is responsible for adding or modifying nodes, properties, and values as
+ * necessary to ensure the DTB is in a valid state for the board.
+ *
+ * The fixups are applied in the following order:
+ * 1. Add any necessary nodes or properties
+ * 2. Modify existing nodes or properties
+ * 3. Remove any unnecessary nodes or properties
+ *
+ * Each fixup is documented with a comment explaining its purpose and any
+ * relevant details.
+ */
+
+#include <dm.h>
+#include <fdt_support.h>
+#include <smem.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <linux/libfdt.h>
+#include <soc/qcom/socinfo.h>
+#include "chipinfo_def.h"
+#include "qcom_fixup_handlers.h"
+
+static const char *const feature_code_names_external[] = {
+	[CHIPINFO_SKU_UNKNOWN] = "Unknown",
+	[CHIPINFO_SKU_AA] = "AA",
+	[CHIPINFO_SKU_AB] = "AB",
+	[CHIPINFO_SKU_AC] = "AC",
+	[CHIPINFO_SKU_AD] = "AD",
+	[CHIPINFO_SKU_AE] = "AE",
+	[CHIPINFO_SKU_AF] = "AF",
+};
+
+static int board_serial_num(u32 *serial_num_ptr);
+static int add_serialnum_platinfo_prop(void *fdt_ptr, u32 node_offset);
+static int add_sku_prop(void *fdt_ptr, u32 node_offset);
+static int add_platforminfo_node(void *fdt_ptr);
+static void add_platforminfo_properties(void *fdt_ptr);
+
+/**
+ * board_serial_num() - Retrieves the board serial number from the s/system/SMEM.
+ * @serial_num_ptr: Pointer to a u32 variable to store the board
+ * serial number.
+ *
+ * Return: 0 on success, negative error code on failure.
+ */
+static int board_serial_num(u32 *serial_num_ptr)
+{
+	struct socinfo *soc_info_ptr;
+	struct udevice *dev_ptr;
+	size_t total_size;
+
+	if (uclass_get_device(UCLASS_SMEM, 0, &dev_ptr) != 0)
+		return log_msg_ret("Error: uclass_get_device\n", -1);
+	soc_info_ptr = smem_get(dev_ptr, 0, SMEM_HW_SW_BUILD_ID, &total_size);
+
+	if (!soc_info_ptr)
+		return log_msg_ret("Error Failed to Get SOC Info Pointer\n",
+				   -1);
+	*serial_num_ptr = soc_info_ptr->serial_num;
+
+	return 0;
+}
+
+/**
+ * add_serialnum_platinfo_prop() - Adds the serial number property to the platform information node.
+ * @fdt_ptr: Pointer to the device tree.
+ * @node_offset: Offset of the platform information node in the device tree.
+ *
+ * This function adds the serial number property to the platform information
+ * node in the device tree. The serial number is retrieved from the SMEM using
+ * the board_serial_num function.
+ *
+ * Return: 0 on success, negative on failure.
+ */
+static int add_serialnum_platinfo_prop(void *fdt_ptr, u32 node_offset)
+{
+	u32 serial_num;
+	int ret;
+
+	ret = board_serial_num(&serial_num);
+	if (ret)
+		return log_msg_ret("ERROR: Could not find serial number to populate\n",
+				   ret);
+	log_debug("Serial Number: 0x%x\n", serial_num);
+
+	ret = fixup_dt_node(fdt_ptr, node_offset, "serial-number",
+			    (void *)&serial_num, SET_PROP_U32);
+	if (ret)
+		log_err("ERROR: Cannot update Platform info node with SerialNumber - %d\n",
+			ret);
+
+	return ret;
+}
+
+static int add_sku_prop(void *fdt_ptr, u32 node_offset)
+{
+	u32 pcode;
+	char feature_code[24];
+	int ret;
+	static const char feature_code_prop[] = "feature-code";
+	struct socinfo *soc_info_ptr;
+	struct udevice *dev_ptr;
+	size_t total_size;
+
+	if (uclass_get_device(UCLASS_SMEM, 0, &dev_ptr) != 0)
+		return log_msg_ret("Error: uclass_get_device\n", -1);
+
+	soc_info_ptr = smem_get(dev_ptr, 0, SMEM_HW_SW_BUILD_ID, &total_size);
+	if (!soc_info_ptr)
+		return log_msg_ret("Error Failed to Get SOC Info Pointer\n",
+				   -1);
+
+	strlcpy(feature_code,
+		feature_code_names_external[soc_info_ptr->feature_code],
+		sizeof(feature_code));
+	if (soc_info_ptr->pcode == 0)
+		pcode = 0xFFFFFFFF;
+	else
+		pcode = soc_info_ptr->pcode;
+
+	ret = fixup_dt_node(fdt_ptr, node_offset, "pcode", (void *)&pcode,
+			    SET_PROP_U32);
+	if (ret)
+		return log_msg_ret("ERROR: Cannot update Platform info node with Pcode\n",
+				   ret);
+	ret = fixup_dt_node(fdt_ptr, node_offset, feature_code_prop,
+			    (void *)feature_code, SET_PROP_STRING);
+	if (ret)
+		log_err("ERROR: Cannot update Platform info node with feature code - %d\n",
+			ret);
+
+	return ret;
+}
+
+/**
+ * add_platforminfo_node() - Adds the platform info node to the device tree.
+ * @fdt_ptr: The device tree to add the platform info node to.
+ *
+ * This function adds the platform info node to the device tree, including the
+ * serial number, SKU information, and other relevant properties.
+ *
+ * Return: 0 on success, negative error code on failure.
+ */
+static int add_platforminfo_node(void *fdt_ptr)
+{
+	int node_offset;
+
+	node_offset = fdt_path_offset(fdt_ptr, "/firmware/qcom,platform-parts-info");
+	if (node_offset >= 0)
+		return node_offset;
+
+	node_offset = fdt_path_offset(fdt_ptr, "/firmware");
+	if (node_offset < 0) {
+		node_offset = fixup_dt_node(fdt_ptr, 0, "firmware", NULL,
+					    ADD_SUBNODE);
+		if (node_offset < 0)
+			return log_msg_ret("Error creating firmware node\n",
+					   node_offset);
+	}
+
+	node_offset = fixup_dt_node(fdt_ptr, node_offset, "qcom,platform-parts-info",
+				    NULL, ADD_SUBNODE);
+	if (node_offset < 0) {
+		log_err("Error adding qcom,platform-parts-info, Error: %d\n",
+			node_offset);
+		node_offset = fdt_path_offset(fdt_ptr,
+					      "/firmware/qcom,platform-parts-info");
+		if (node_offset < 0)
+			log_err("Retry getting qcom,platform-parts-info offset, Error: %d\n",
+				node_offset);
+	}
+
+	return node_offset;
+}
+
+/**
+ * add_platforminfo_properties() - Adds platform information properties to the device tree.
+ * @fdt_ptr: The device tree to update.
+ *
+ * This function populates the device tree with platform information properties,
+ * including the serial number, SKU information, and platform parts information.
+ *
+ * Return: 0 on success, negative error code on failure.
+ */
+static void add_platforminfo_properties(void *fdt_ptr)
+{
+	int ret = 0;
+	int node_offset;
+
+	node_offset = add_platforminfo_node(fdt_ptr);
+	if (node_offset < 0) {
+		log_err("Failed to add qcom,platform-parts-info\n");
+		return;
+	}
+
+	ret = add_serialnum_platinfo_prop(fdt_ptr, node_offset);
+	if (ret)
+		log_err("Failed to add Serial Number property\n");
+
+	ret = add_sku_prop(fdt_ptr, node_offset);
+	if (ret)
+		log_err("Failed to add SKU properties\n");
+}
+
+/**
+ * boardinfo_fixup_handler() - Board info fixup handler.
+ * @fdt_ptr: Pointer to the device tree.
+ *
+ * This function is called to fix up the device tree blob (DTB) for the board.
+ * It adds or modifies nodes, properties, and values as necessary to ensure the
+ * DTB is in a valid state for the board.
+ */
+void boardinfo_fixup_handler(struct fdt_header *fdt_ptr)
+{
+	add_platforminfo_properties(fdt_ptr);
+}
diff --git a/arch/arm/mach-snapdragon/qcom_fixup_ddrinfo.c b/arch/arm/mach-snapdragon/qcom_fixup_ddrinfo.c
new file mode 100644
index 0000000000..e04de1bc24
--- /dev/null
+++ b/arch/arm/mach-snapdragon/qcom_fixup_ddrinfo.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * DDRInfo Fixup
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <dm.h>
+#include <fdt_support.h>
+#include <smem.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <linux/libfdt.h>
+#include "qcom_fixup_handlers.h"
+
+/* With the new SMEM architecture, SMEM IDs need to be defined in individual
+ * driver files
+ */
+#define SMEM_ID_DDRINFO 0x25B // 603
+#define MAX_IDX_CH 8
+
+struct ddr_freq_table {
+	u32 freq_khz;
+	u8 enable;
+};
+
+struct ddr_freq_plan_entry {
+	struct ddr_freq_table ddr_freq[14];
+	u8 num_ddr_freqs;
+	u32 *clk_period_address;
+	u32 max_nom_ddr_freq;
+};
+
+struct ddr_part_details {
+	u8 revision_id1[2];
+	u8 revision_id2[2];
+	u8 width[2];
+	u8 density[2];
+};
+
+struct ddr_details_entry {
+	u8 manufacturer_id;
+	u8 device_type;
+	struct ddr_part_details ddr_params[MAX_IDX_CH];
+	struct ddr_freq_plan_entry ddr_freq_tbl;
+	u8 num_channels;
+	u8 num_ranks[2]; /* number of ranks per channel */
+	u8 hbb[2][2];
+	/* Highest Bank Bit per rank per channel */ /*Reserved for Future use*/
+};
+
+static int get_ddr_details(struct ddr_details_entry *ddr_detail);
+
+/**
+ * get_ddr_details() - Retrieves the DDR details entry from the SMEM.
+ * @ddr_detail: The DDR details entry to retrieve.
+ *
+ * This function retrieves the DDR details entry from the SMEM and prints it
+ * out.
+ *
+ * Return: 0 on success, -1 on failure
+ */
+static int get_ddr_details(struct ddr_details_entry *ddr_detail)
+{
+	void *ddr_table_ptr;
+	struct udevice *dev;
+	size_t size;
+
+	if (uclass_get_device(UCLASS_SMEM, 0, &dev) != 0)
+		return log_msg_ret("Error: uclass_get_device\n", -1);
+	ddr_table_ptr = smem_get(dev, 0, SMEM_ID_DDRINFO, &size);
+
+	if (!ddr_table_ptr)
+		return log_msg_ret("Error: invalid DDR Entry\n", -1);
+	memcpy((void *)ddr_detail, ddr_table_ptr, sizeof(struct ddr_details_entry));
+
+	return 0;
+}
+
+/**
+ * ddrinfo_fixup_handler() - DDRInfo Fixup handler function
+ * @fdt_ptr: Pointer to the device tree
+ *
+ * This function is responsible for updating the DDR information in the device
+ * tree.
+ */
+void ddrinfo_fixup_handler(struct fdt_header *fdt_ptr)
+{
+	u32 path_offset, chan, ret;
+	u32 value[] = { 0x00, 0x90000000, 0x00, 0x00 };
+	u64 prop_value;
+	char fdt_rank_prop[] = "ddr_device_rank_ch ";
+	struct ddr_details_entry ddr_details;
+
+	ret = get_ddr_details(&ddr_details);
+	if (ret) {
+		log_err("Error getting DDR details\n");
+		return;
+	}
+
+	path_offset = fdt_path_offset(fdt_ptr, "/memory");
+	if (path_offset < 0) {
+		log_err("Error getting memory offset: %d\n", path_offset);
+		return;
+	}
+	prop_value = (u64)ddr_details.device_type;
+	ret = fixup_dt_node(fdt_ptr, path_offset, "ddr_device_type",
+			    (void *)(&prop_value), APPEND_PROP_U64);
+	if (ret)
+		log_err("Failed to append DDR device type data : %d\n", ret);
+
+	prop_value = (u64)ddr_details.num_channels;
+	ret = fixup_dt_node(fdt_ptr, path_offset, "ddr_device_channel",
+			    (void *)(&prop_value), APPEND_PROP_U64);
+	if (ret)
+		log_err("Failed to append DDR Channels data : %d\n", ret);
+
+	for (chan = 0; chan < ddr_details.num_channels; chan++) {
+		snprintf(fdt_rank_prop, sizeof(fdt_rank_prop),
+			 "ddr_device_rank_ch%d", chan);
+		prop_value = (u64)ddr_details.num_ranks[chan];
+		ret = fixup_dt_node(fdt_ptr, path_offset,
+				    (const char *)fdt_rank_prop,
+				    (void *)(&prop_value),
+				    APPEND_PROP_U64);
+		if (ret)
+			log_err("Failed to append DDR ranks data : %d\n", ret);
+	}
+	fdt_setprop_inplace(fdt_ptr, path_offset, "reg", value, 16);
+}
+
+/* End of File */
diff --git a/arch/arm/mach-snapdragon/qcom_fixup_handlers.h b/arch/arm/mach-snapdragon/qcom_fixup_handlers.h
new file mode 100644
index 0000000000..efe8113891
--- /dev/null
+++ b/arch/arm/mach-snapdragon/qcom_fixup_handlers.h
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * SUBSET Parts Fixup: A tool for fixing up subset parts in a system
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <linux/libfdt.h>
+
+enum fdt_fixup_type {
+	APPEND_PROP_U32 = 0,
+	APPEND_PROP_U64 = 1,
+	SET_PROP_U32 = 2,
+	SET_PROP_U64 = 3,
+	SET_PROP_STRING = 4,
+	ADD_SUBNODE = 5,
+};
+
+/**
+ * boardinfo_fixup_handler() - Board info fixup handler.
+ * @fdt_ptr: Pointer to the device tree.
+ *
+ * This function is called to fix up the device tree blob (DTB) for the board.
+ * It adds or modifies nodes, properties, and values as necessary to ensure
+ * the DTB is in a valid state for the board.
+ *
+ * Return: None
+ */
+void boardinfo_fixup_handler(struct fdt_header *fdt_ptr);
+
+/**
+ * subsetparts_fixup_handler() - This function is the entry point for the
+ * Subset Parts fixup handler.
+ * @fdt_ptr: The firmware DT node to update.
+ *
+ * It reads the SOC info from the SMEM, extracts the disabled subset parts, and
+ * exports them to the firmware DT node.
+ *
+ * Return: None
+ */
+void subsetparts_fixup_handler(struct fdt_header *fdt_ptr);
+
+/**
+ * ddrinfo_fixup_handler() - DDRInfo Fixup handler function
+ * @fdt_ptr: Pointer to the device tree
+ *
+ * This function is responsible for updating the DDR information in
+ * the device tree.
+ *
+ * Return: None
+ */
+void ddrinfo_fixup_handler(struct fdt_header *fdt_ptr);
+
+/**
+ * hypervisor_fixup_handler() - This function is responsible for
+ * updating the device tree with the hypervisor boot information.
+ * @fdt_ptr: A pointer to the device tree header.
+ *
+ * Return: None
+ */
+void hypervisor_fixup_handler(struct fdt_header *fdt_ptr);
+
+/**
+ * fixup_dt_node() - Exports a property to the firmware DT node.
+ * @fdt_ptr: The firmware DT node to update.
+ * @node_offset: The offset in the DT node where the property should be set.
+ * @property_name: The name of the property to set.
+ * @property_value: The value of the property to set.
+ * @type: Fixup type
+ * This function sets a property in the firmware DT node with the given name and
+ * value.
+ *
+ * Return: 0 on success, negative on failure.
+ */
+int fixup_dt_node(void *fdt_ptr, int node_offset,
+		  const char *property_name,
+		  void *property_value,
+		  enum fdt_fixup_type type);
diff --git a/arch/arm/mach-snapdragon/qcom_fixup_hypervisor.c b/arch/arm/mach-snapdragon/qcom_fixup_hypervisor.c
new file mode 100644
index 0000000000..a8948546c1
--- /dev/null
+++ b/arch/arm/mach-snapdragon/qcom_fixup_hypervisor.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* Hypervisor Fixup
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <fdt_support.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <linux/libfdt.h>
+#include "qcom_fixup_handlers.h"
+
+#define HYP_BOOTINFO_MAGIC 0xC06B0071
+#define HYP_MAX_NUM_DTBOS 4
+#define SMC_HYPERVISOR_PARAM_ID (u32)0x42000609
+#define SCM_HYP_DTB_RESULT 1
+
+struct __packed hyp_boot_info {
+	u32 hyp_boot_info_magic;
+	u32 hyp_boot_info_version;
+	u32 hyp_boot_info_size;
+	u32 pil_enable;
+	struct {
+		u32 vm_type;
+		u32 num_dtbos;
+		union {
+			struct {
+				u64 dtbo_base;
+				u64 dtbo_size;
+			} linux_aarch64[HYP_MAX_NUM_DTBOS];
+			/* union padding */
+			u32 vm_info[16];
+		} info;
+	} primary_vm_info;
+};
+
+struct boot_param_list {
+	u32 num_hyp_dtbos;
+	u64 *hyp_dtbo_base_addr;
+};
+
+static bool is_vm_enabled;
+static struct hyp_boot_info *hyp_info;
+
+static void smc_wrapper_call(u32 *regs_ptr);
+static int check_and_set_vm_data(struct boot_param_list *pboot_param_list_ptr);
+static struct hyp_boot_info *get_vm_data(void);
+static int set_hyp_info(struct boot_param_list *pboot_param_list_ptr,
+			struct hyp_boot_info *hyp_info_ptr);
+
+/**
+ * smc_wrapper_call() - issue the secure monitor call
+ * @regs_ptr: pointer to an array of 8 u32 values representing the input and
+ * output arguments x0~x7: input arguments x0~x3: output arguments
+ *
+ * This function issues a secure monitor call using the SMC instruction.
+ * It loads the input arguments into the registers and then calls the SMC
+ * instruction. The output arguments are stored in the registers.
+ */
+static void smc_wrapper_call(u32 *regs_ptr)
+{
+	asm volatile("ldr x0, %0\n"
+		     "ldr x1, %1\n"
+		     "ldr x2, %2\n"
+		     "ldr x3, %3\n"
+		     "ldr x4, %4\n"
+		     "ldr x5, %5\n"
+		     "ldr x6, %6\n"
+		     "smc     #0\n"
+		     "str x0, %0\n"
+		     "str x1, %1\n"
+		     "str x2, %2\n"
+		     "str x3, %3\n"
+		     : "+m"(regs_ptr[0]), "+m"(regs_ptr[1]),
+		     "+m"(regs_ptr[2]), "+m"(regs_ptr[3])
+		     : "m"(regs_ptr[4]), "m"(regs_ptr[5]), "m"(regs_ptr[6])
+		     : "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8",
+		     "x9", "x10",
+		     "x11", "x12", "x13", "x14", "x15", "x16", "x17");
+}
+
+/**
+ * hyp_boot_info() - Retrieves the Hypervisor Boot Information.
+ *
+ * This function issues a secure monitor call to retrieve the Hypervisor Boot
+ * Information. If the Hypervisor is enabled, it returns the Hypervisor Boot
+ * Information. Otherwise, it issues the secure monitor call and retrieves the
+ * Hypervisor Boot Information.
+ *
+ * Return: A pointer to the Hypervisor Boot Information structure.
+ */
+static struct hyp_boot_info *get_vm_data(void)
+{
+	u32 l_param[32] = { 0 };
+
+	l_param[0] = SMC_HYPERVISOR_PARAM_ID;
+	if (is_vm_enabled)
+		return hyp_info;
+
+	smc_wrapper_call(l_param);
+
+	log_debug(" SMC call return .. R[0-3]: 0x%x | 0x%x | 0x%x | 0x%x | 0x%x | 0x%x\n",
+		  l_param[0], l_param[1], l_param[2], l_param[3], l_param[4],
+		  l_param[5]);
+
+	hyp_info = (struct hyp_boot_info *)(uintptr_t)l_param[SCM_HYP_DTB_RESULT];
+	if (!hyp_info)
+		return hyp_info;
+	is_vm_enabled = true;
+
+	return hyp_info;
+}
+
+/**
+ * set_hyp_info() - Set the Hypervisor Boot Information
+ * @pboot_param_list_ptr: Pointer to the BootParamlist structure
+ * @hyp_info_ptr: Pointer to the HypBootInfo structure
+ *
+ * This function sets the Hypervisor Boot Information based on the provided
+ * BootParamlist and HypBootInfo.
+ *
+ * Return: 0 on success, -1 on failure
+ */
+static int set_hyp_info(struct boot_param_list *pboot_param_list_ptr,
+			struct hyp_boot_info *hyp_info_ptr)
+{
+	u32 idx;
+	u32 num_dtbos;
+	u64 *dtbo_base_addr_ptr;
+
+	if (hyp_info_ptr->hyp_boot_info_magic != HYP_BOOTINFO_MAGIC)
+		return log_msg_ret("Invalid HYP MAGIC\n", -1);
+
+	num_dtbos = hyp_info_ptr->primary_vm_info.num_dtbos;
+	if (num_dtbos > HYP_MAX_NUM_DTBOS) {
+		log_err("hyp_info_ptr: Invalid number of dtbos: %d max supported: %d\n",
+			num_dtbos, HYP_MAX_NUM_DTBOS);
+		num_dtbos = HYP_MAX_NUM_DTBOS;
+	}
+
+	dtbo_base_addr_ptr = (u64 *)calloc(num_dtbos, sizeof(u64));
+	if (!dtbo_base_addr_ptr)
+		return log_msg_ret("hyp_info_ptr: Failed to allocate memory\n",
+				   -1);
+
+	for (idx = 0; idx < num_dtbos; idx++) {
+		dtbo_base_addr_ptr[idx] = hyp_info_ptr->primary_vm_info
+					  .info.linux_aarch64[idx].dtbo_base;
+	}
+
+	pboot_param_list_ptr->num_hyp_dtbos = num_dtbos;
+	pboot_param_list_ptr->hyp_dtbo_base_addr = dtbo_base_addr_ptr;
+
+	return 0;
+}
+
+/**
+ * check_and_set_vm_data() - Checks if the VM data is available and updates the BootParamlist if it
+ * is.
+ * @pboot_param_list_ptr: Pointer to the BootParamlist structure to be updated
+ *
+ * This function calls the secure monitor call to retrieve the VM data and then
+ * updates the BootParamlist with the retrieved data.
+ *
+ * Return: 0 on success, -1 on failure
+ */
+static int check_and_set_vm_data(struct boot_param_list *pboot_param_list_ptr)
+{
+	int status;
+	struct hyp_boot_info *hyp_boot_info_ptr = get_vm_data();
+
+	if (!hyp_boot_info_ptr)
+		return log_msg_ret("hyp_info_ptr is NULL\n", -1);
+
+	status = set_hyp_info(pboot_param_list_ptr, hyp_boot_info_ptr);
+	if (status != 0)
+		log_err("Failed to update HypInfo!! Status:%d\n", status);
+
+	return status;
+}
+
+/**
+ * add_overlay_fdt() - Adds overlay FDT to base FDT.
+ * @fdt_ptr: A pointer to the device tree header.
+ * @dtbo_base_addr_ptr: The address of the new entry.
+ *
+ * Return: true if the operation is successful, false otherwise.
+ */
+static bool add_overlay_fdt(struct fdt_header *fdt_ptr, void *dtbo_base_addr_ptr)
+{
+	int ret;
+	u32 hyp_offset;
+
+	ret = fdt_increase_size(fdt_ptr, fdt_totalsize(dtbo_base_addr_ptr));
+	log_debug("%s: fdt increase size proccessed result- %d\n",
+		  __func__, ret);
+
+	hyp_offset = fdt_path_offset(dtbo_base_addr_ptr,
+				     "/fragment@0/__overlay__");
+	if (hyp_offset < 0) {
+		log_err("Error getting overlay offset: %d\n", hyp_offset);
+		return false;
+	}
+
+	log_debug("%s: Hyp fdt offset- %d\n", __func__, hyp_offset);
+
+	log_debug("%s: Before Overlay Fdt@0x%p | %lu - 0x%lx\n", __func__,
+		  fdt_ptr, fdt_totalsize(fdt_ptr), fdt_totalsize(fdt_ptr));
+
+	ret = fdt_overlay_apply_node(fdt_ptr, 0, dtbo_base_addr_ptr,
+				     hyp_offset);
+	if (ret != 0) {
+		log_err("HypDtFixupEventNotifyFunc: fdt_overlay_apply failed Ret: %d\n",
+			ret);
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * hypervisor_fixup_handler() - This function is responsible for updating
+ * the device tree with the hypervisor boot information.
+ * @fdt_ptr: A pointer to the device tree header.
+ *
+ * Return: None
+ */
+void hypervisor_fixup_handler(struct fdt_header *fdt_ptr)
+{
+	struct boot_param_list boot_params_list;
+	int ret, idx;
+	int status = check_and_set_vm_data(&boot_params_list);
+
+	if (status != 0) {
+		log_err("Failed to update HypData!! Status:%d\n", status);
+		return;
+	}
+
+	if (is_vm_enabled) {
+		if (!boot_params_list.hyp_dtbo_base_addr) {
+			log_err("Error: HypOverlay DT is NULL\n");
+			return;
+		}
+
+		for (idx = 0; idx < boot_params_list.num_hyp_dtbos; idx++) {
+			if (!boot_params_list.hyp_dtbo_base_addr[idx]) {
+				log_err("Not overlaying hyp Dtbo :%d is null or Bad DT header\n",
+					idx);
+				continue;
+			}
+			/*handled for first overlay only,
+			 *need to support for multiple in future
+			 */
+			if (idx == 0)
+				add_overlay_fdt(fdt_ptr,
+						(void *)boot_params_list
+						.hyp_dtbo_base_addr[idx]);
+		}
+	}
+	log_debug("%s: Dtb apply overlay is success\n", __func__);
+}
diff --git a/arch/arm/mach-snapdragon/qcom_fixup_subsetparts.c b/arch/arm/mach-snapdragon/qcom_fixup_subsetparts.c
new file mode 100644
index 0000000000..5c4e039a84
--- /dev/null
+++ b/arch/arm/mach-snapdragon/qcom_fixup_subsetparts.c
@@ -0,0 +1,289 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* SUBSET Parts Fixup: A tool for fixing up subset parts in a system
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include <dm.h>
+#include <fdt_support.h>
+#include <smem.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <linux/libfdt.h>
+#include <soc/qcom/socinfo.h>
+#include "chipinfo_def.h"
+#include "qcom_fixup_handlers.h"
+
+static const unsigned char *const part_names[] = {
+	[CHIPINFO_PART_GPU] = "gpu",
+	[CHIPINFO_PART_VIDEO] = "video",
+	[CHIPINFO_PART_CAMERA] = "camera",
+	[CHIPINFO_PART_DISPLAY] = "display",
+	[CHIPINFO_PART_AUDIO] = "audio",
+	[CHIPINFO_PART_MODEM] = "modem",
+	[CHIPINFO_PART_WLAN] = "wlan",
+	[CHIPINFO_PART_COMP] = "compute",
+	[CHIPINFO_PART_SENSORS] = "sensors",
+	[CHIPINFO_PART_NPU] = "npu",
+	[CHIPINFO_PART_SPSS] = "spss",
+	[CHIPINFO_PART_NAV] = "nav",
+	[CHIPINFO_PART_COMPUTE_1] = "compute1",
+	[CHIPINFO_PART_DISPLAY_1] = "display1",
+	[CHIPINFO_PART_NSP] = "nsp",
+	[CHIPINFO_PART_EVA] = "eva",
+	[CHIPINFO_PART_PCIE] = "pcie",
+};
+
+static int chipinfo_get_disabled_cpus(u32 *value_ptr);
+static int read_cpu_subset_parts(u32 *value);
+static int chipinfo_get_disabled_features(u32 chip_info_type_idx,
+					  u32 *disabled_feature_ptr);
+static int read_mm_subset_parts(u32 *value_ptr);
+static void read_and_export_parts_disabled_features(void *fdt_ptr,
+						    int node_offset);
+static int add_platform_info_node(void *fdt_ptr);
+
+/**
+ * chipinfo_get_disabled_cpus() - Retrieves the disabled CPUs from the SOC info.
+ * @value_ptr: A pointer to a u32 variable to store the disabled CPUs.
+ *
+ * This function reads the SOC info from the SMEM and extracts the disabled
+ * CPUs.
+ *
+ * Return: 0 on success, negative on failure.
+ */
+static int chipinfo_get_disabled_cpus(u32 *value_ptr)
+{
+	u32 *subset_ptr;
+	struct udevice *dev_ptr;
+	size_t total_size;
+	struct socinfo *soc_info_ptr;
+
+	if (uclass_get_device(UCLASS_SMEM, 0, &dev_ptr) != 0)
+		return log_msg_ret("Error: uclass_get_device\n", -1);
+	soc_info_ptr = smem_get(dev_ptr, 0, SMEM_HW_SW_BUILD_ID, &total_size);
+	if (!soc_info_ptr)
+		return log_msg_ret("Error Failed to Get SOC Info Pointer\n",
+				   -1);
+
+	if (soc_info_ptr->num_clusters == 0x0) {
+		*value_ptr = 0x0;
+	} else {
+		subset_ptr = (u32 *)(soc_info_ptr
+			     + soc_info_ptr->ncluster_array_offset);
+		*value_ptr = (u32)(subset_ptr[0]);
+	}
+
+	return 0;
+}
+
+/**
+ * read_cpu_subset_parts() - Retrieves the disabled CPUs from the SOC info.
+ * @value: A pointer to a u32 variable to store the disabled CPUs.
+ *
+ * This function reads the SOC info from the SMEM and extracts the disabled
+ * CPUs.
+ *
+ * Return: 0 on success, negative on failure.
+ */
+static int read_cpu_subset_parts(u32 *value)
+{
+	int ret;
+
+	ret = chipinfo_get_disabled_cpus(value);
+	if (ret)
+		log_err("Failed to get subset[0] CPU. %d\n", ret);
+
+	return ret;
+}
+
+/**
+ * chipinfo_get_disabled_features() - Retrieves the disabled features from the SOC info.
+ * @chip_info_type_idx: The index of the chip info type to retrieve the
+ * disabled features for.
+ * @disabled_feature_ptr: A pointer to a u32 variable to store the disabled features.
+ *
+ * This function reads the SOC info from the SMEM and extracts the disabled
+ * features.
+ *
+ * Return: CHIPINFO_SUCCESS on success, CHIPINFO_ERROR_INVALID_PARAMETER on
+ * failure.
+ */
+static int chipinfo_get_disabled_features(u32 chip_info_type_idx,
+					  u32 *disabled_feature_ptr)
+{
+	u32 *subset_ptr;
+	struct socinfo *soc_info_ptr;
+	struct udevice *dev_ptr;
+	size_t total_size;
+
+	if (chip_info_type_idx >= CHIPINFO_NUM_PARTS)
+		return CHIPINFO_ERROR_INVALID_PARAMETER;
+
+	if (uclass_get_device(UCLASS_SMEM, 0, &dev_ptr) != 0)
+		return CHIPINFO_ERROR_INVALID_PARAMETER;
+
+	soc_info_ptr = smem_get(dev_ptr, 0, SMEM_HW_SW_BUILD_ID, &total_size);
+	if (!soc_info_ptr)
+		return log_msg_ret("Error Failed to Get SOC Info Pointer\n",
+				   -1);
+
+	subset_ptr = (u32 *)(soc_info_ptr
+		     + soc_info_ptr->nsubset_parts_array_offset);
+	*disabled_feature_ptr = (u32)(subset_ptr[chip_info_type_idx]);
+
+	return CHIPINFO_SUCCESS;
+}
+
+/**
+ * read_mm_subset_parts() - Retrieves the disabled MM subset parts from the SOC info.
+ * @value_ptr: A pointer to a u32 variable to store the disabled MM
+ * subset parts.
+ *
+ * This function reads the SOC info from the SMEM and extracts the disabled MM
+ * subset parts.
+ *
+ * Return: 0 on success, negative on failure.
+ */
+static int read_mm_subset_parts(u32 *value_ptr)
+{
+	u32 idx;
+	u32 subset_val;
+	int ret;
+	*value_ptr = 0;
+
+	for (idx = 1; idx < CHIPINFO_NUM_PARTS; idx++) {
+		subset_val = 0;
+		ret = chipinfo_get_disabled_features(idx, &subset_val);
+		if (ret) {
+			log_err("Failed to get MM subset[%d] part. %d\n",
+				idx, ret);
+			continue;
+		}
+		*value_ptr |= ((subset_val & 0x01) << idx);
+	}
+	return ret;
+}
+
+/**
+ * read_and_export_parts_disabled_features() - Reads and exports the disabled
+ * features for each part.
+ * @fdt_ptr: The firmware DT node to update.
+ * @node_offset: The offset in the DT node where the features should be set.
+ *
+ * This function reads the SOC info from the SMEM and extracts the disabled
+ * features for each part. It then exports these features to the firmware DT
+ * node.
+ */
+static void read_and_export_parts_disabled_features(void *fdt_ptr, int node_offset)
+{
+	u32 mask, n_idx = 0, n_parts = 1;
+	int offset_child;
+	char str_buffer[24];
+	int ret, part;
+
+	for (part = CHIPINFO_PART_GPU; part <= CHIPINFO_PART_PCIE; part++) {
+		mask = 0;
+		ret = chipinfo_get_disabled_features(n_idx, &mask);
+		if (ret) {
+			log_err("Failed to get Part %s information. %d\n",
+				part_names[part], ret);
+			mask = UINT32_MAX;
+			n_parts = UINT32_MAX;
+		}
+		snprintf(str_buffer, sizeof(str_buffer), "subset-%s",
+			 part_names[part]);
+		offset_child = fixup_dt_node(fdt_ptr, node_offset,
+					     str_buffer, NULL, ADD_SUBNODE);
+		if (offset_child < 0) {
+			log_err("Error adding %s, Error: %d\n", str_buffer,
+				offset_child);
+			continue;
+		}
+		ret = fixup_dt_node(fdt_ptr, offset_child, "part-info",
+				    (void *)&mask, SET_PROP_U32);
+		if (ret)
+			log_err("ERROR: Cannot update part-info prop\n");
+
+		ret = fixup_dt_node(fdt_ptr, offset_child, "part-count",
+				    (void *)&n_parts, SET_PROP_U32);
+		if (ret)
+			log_err("ERROR: Cannot update part-count prop\n");
+	}
+}
+
+/**
+ * add_platform_info_node() - Adds the platform info node to the firmware DT.
+ * @fdt_ptr: The firmware DT to update.
+ *
+ * This function creates the platform info node in the firmware DT and sets its
+ * properties.
+ *
+ * Return: The offset of the platform info node on success, negative on failure.
+ */
+static int add_platform_info_node(void *fdt_ptr)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt_ptr, "/firmware/qcom,platform-parts-info");
+	if (offset >= 0)
+		return offset;
+	offset = fdt_path_offset(fdt_ptr, "/firmware");
+	if (offset < 0) {
+		offset = fixup_dt_node(fdt_ptr, 0, "firmware", NULL, ADD_SUBNODE);
+		if (offset < 0)
+			return log_msg_ret("Error creating firmware node\n",
+				offset);
+	}
+	offset = fixup_dt_node(fdt_ptr, offset, "qcom,platform-parts-info", NULL,
+			       ADD_SUBNODE);
+	if (offset < 0)
+		log_err("Error adding qcom,platform-parts-info, Error: %d\n",
+			offset);
+
+	return offset;
+}
+
+/**
+ * subsetparts_fixup_handler() - This function is the entry point for the
+ * Subset Parts fixup handler.
+ * @fdt_ptr: The firmware DT node to update.
+ *
+ * It reads the SOC info from the SMEM, extracts the disabled subset parts, and
+ * exports them to the firmware DT node.
+ */
+void subsetparts_fixup_handler(struct fdt_header *fdt_ptr)
+{
+	u32 subset_parts_mm_value;
+	u32 subset_parts_cpu_value;
+	int offset;
+	int ret;
+
+	offset = add_platform_info_node(fdt_ptr);
+	if (offset < 0) {
+		log_err("Failed to add qcom,platform-parts-info node in %s\n",
+			__func__);
+		return;
+	}
+	ret = read_mm_subset_parts(&subset_parts_mm_value);
+	if (ret)
+		log_err("No mm Subset parts found\n");
+	else
+		ret = fixup_dt_node(fdt_ptr, offset, "subset-parts",
+				    (void *)&subset_parts_mm_value, SET_PROP_U32);
+		if (ret)
+			log_err("ERROR: Cannot update subset-parts prop\n");
+
+	ret = read_cpu_subset_parts(&subset_parts_cpu_value);
+	if (ret)
+		log_err("No Subset parts for cpu ss found\n");
+	else
+		ret = fixup_dt_node(fdt_ptr, offset, "subset-cores",
+				    (void *)&subset_parts_cpu_value, SET_PROP_U32);
+		if (ret)
+			log_err("ERROR: Cannot update subset-cores prop\n");
+
+	read_and_export_parts_disabled_features(fdt_ptr, offset);
+}
diff --git a/arch/arm/mach-snapdragon/qcom_sa8775p_fixup.c b/arch/arm/mach-snapdragon/qcom_sa8775p_fixup.c
new file mode 100644
index 0000000000..d078e8c40a
--- /dev/null
+++ b/arch/arm/mach-snapdragon/qcom_sa8775p_fixup.c
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* DDRInfo Fixup
+ *
+ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
+ *
+ */
+
+#include "qcom_fixup_handlers.h"
+
+/**
+ * fixup_dt_handler() - Calls the device tree fixup handlers.
+ * @fdt_ptr The firmware DT node to update.
+ *
+ * This function retrieves the DDR details entry from the SMEM and prints it
+ * out.
+ */
+void fixup_dt_handler(struct fdt_header *fdt_ptr)
+{
+	boardinfo_fixup_handler(fdt_ptr);
+	ddrinfo_fixup_handler(fdt_ptr);
+	subsetparts_fixup_handler(fdt_ptr);
+	hypervisor_fixup_handler(fdt_ptr);
+}
-- 
2.34.1

