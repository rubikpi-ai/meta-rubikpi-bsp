From d41664447460bb8b031d53e3f8ac3a881c57fd17 Mon Sep 17 00:00:00 2001
From: Yuanjie Yang <quic_yuanjiey@quicinc.com>
Date: Tue, 11 Mar 2025 17:23:23 +0800
Subject: [PATCH] QCLINUX: firmware: qcom_scm: allow scm addon to be compiled
 into a module

To facilitate the dynamic loading of features in the scm addon, refactor
QCOM_SCM_ADDON to allow scm addon to be compiled into a module.

Signed-off-by: Yuanjie Yang <quic_yuanjiey@quicinc.com>
Upstream-Status: Pending
---
 drivers/firmware/Kconfig          |  2 +-
 drivers/firmware/Makefile         |  1 +
 drivers/firmware/qcom_scm.c       | 43 ++++++++++---------------------
 drivers/firmware/qcom_scm.h       | 30 +++++++++++++++++++++
 drivers/firmware/qcom_scm_addon.c | 30 ++++++++++++++++++++-
 5 files changed, 74 insertions(+), 32 deletions(-)

diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 5363604e0034..c03b2e3ff2b3 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -228,7 +228,7 @@ config QCOM_SCM_DOWNLOAD_MODE_DEFAULT
 	  Say Y here to enable "download mode" by default.
 
 config QCOM_SCM_ADDON
-	bool "Qualcomm SCM Addon Support"
+	tristate "Qualcomm SCM Addon Support"
 	depends on QCOM_SCM
 	help
 	  QCOM SCM addon provision APIs for client like kgsl, SHMBridge, etc,
diff --git a/drivers/firmware/Makefile b/drivers/firmware/Makefile
index a2f22d45d9f1..eb540030b410 100644
--- a/drivers/firmware/Makefile
+++ b/drivers/firmware/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_RASPBERRYPI_FIRMWARE) += raspberrypi.o
 obj-$(CONFIG_FW_CFG_SYSFS)	+= qemu_fw_cfg.o
 obj-$(CONFIG_QCOM_SCM)		+= qcom-scm.o
 qcom-scm-objs += qcom_scm.o qcom_scm-smc.o qcom_scm-legacy.o
+obj-$(CONFIG_QCOM_SCM_ADDON) += qcom_scm_addon.o
 obj-$(CONFIG_SYSFB)		+= sysfb.o
 obj-$(CONFIG_SYSFB_SIMPLEFB)	+= sysfb_simplefb.o
 obj-$(CONFIG_TI_SCI_PROTOCOL)	+= ti_sci.o
diff --git a/drivers/firmware/qcom_scm.c b/drivers/firmware/qcom_scm.c
index 5f58b6ee361d..6daf08bd8f43 100644
--- a/drivers/firmware/qcom_scm.c
+++ b/drivers/firmware/qcom_scm.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (c) 2010,2015,2019 The Linux Foundation. All rights reserved.
  * Copyright (C) 2015 Linaro Ltd.
- * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2023, 2025 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 #include <linux/platform_device.h>
 #include <linux/init.h>
@@ -33,23 +33,6 @@
 static bool download_mode = IS_ENABLED(CONFIG_QCOM_SCM_DOWNLOAD_MODE_DEFAULT);
 module_param(download_mode, bool, 0);
 
-struct qcom_scm {
-	struct device *dev;
-	struct clk *core_clk;
-	struct clk *iface_clk;
-	struct clk *bus_clk;
-	struct icc_path *path;
-	struct completion waitq_comp;
-	struct reset_controller_dev reset;
-
-	/* control access to the interconnect path */
-	struct mutex scm_bw_lock;
-	int scm_vote_count;
-
-	u64 dload_mode_addr;
-
-	struct qcom_tzmem_pool *mempool;
-};
 
 struct qcom_scm_current_perm_info {
 	__le32 vmid;
@@ -84,7 +67,8 @@ static const char * const qcom_scm_convention_names[] = {
 	[SMC_CONVENTION_LEGACY] = "smc legacy",
 };
 
-static struct qcom_scm *__scm;
+struct qcom_scm *__scm;
+EXPORT_SYMBOL_GPL(__scm);
 
 static int qcom_scm_clk_enable(void)
 {
@@ -239,8 +223,8 @@ static enum qcom_scm_convention __get_convention(void)
  * Sends a command to the SCM and waits for the command to finish processing.
  * This should *only* be called in pre-emptible context.
  */
-static int qcom_scm_call(struct device *dev, const struct qcom_scm_desc *desc,
-			 struct qcom_scm_res *res)
+int qcom_scm_call(struct device *dev, const struct qcom_scm_desc *desc,
+		  struct qcom_scm_res *res)
 {
 	might_sleep();
 	switch (__get_convention()) {
@@ -254,6 +238,7 @@ static int qcom_scm_call(struct device *dev, const struct qcom_scm_desc *desc,
 		return -EINVAL;
 	}
 }
+EXPORT_SYMBOL_GPL(qcom_scm_call);
 
 /**
  * qcom_scm_call_atomic() - atomic variation of qcom_scm_call()
@@ -264,9 +249,9 @@ static int qcom_scm_call(struct device *dev, const struct qcom_scm_desc *desc,
  * Sends a command to the SCM and waits for the command to finish processing.
  * This can be called in atomic context.
  */
-static int qcom_scm_call_atomic(struct device *dev,
-				const struct qcom_scm_desc *desc,
-				struct qcom_scm_res *res)
+int qcom_scm_call_atomic(struct device *dev,
+			 const struct qcom_scm_desc *desc,
+			 struct qcom_scm_res *res)
 {
 	switch (__get_convention()) {
 	case SMC_CONVENTION_ARM_32:
@@ -279,8 +264,9 @@ static int qcom_scm_call_atomic(struct device *dev,
 		return -EINVAL;
 	}
 }
+EXPORT_SYMBOL_GPL(qcom_scm_call_atomic);
 
-static bool __qcom_scm_is_call_available(struct device *dev, u32 svc_id,
+bool __qcom_scm_is_call_available(struct device *dev, u32 svc_id,
 					 u32 cmd_id)
 {
 	int ret;
@@ -310,6 +296,7 @@ static bool __qcom_scm_is_call_available(struct device *dev, u32 svc_id,
 
 	return ret ? false : !!res.result[0];
 }
+EXPORT_SYMBOL_GPL(__qcom_scm_is_call_available);
 
 static int qcom_scm_set_boot_addr(void *entry, const u8 *cpu_bits)
 {
@@ -1768,10 +1755,6 @@ static irqreturn_t qcom_scm_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-#ifdef CONFIG_QCOM_SCM_ADDON
-#include "qcom_scm_addon.c"
-#endif
-
 static int qcom_scm_probe(struct platform_device *pdev)
 {
 	struct qcom_tzmem_pool_config pool_config;
@@ -1908,4 +1891,4 @@ static int __init qcom_scm_init(void)
 subsys_initcall(qcom_scm_init);
 
 MODULE_DESCRIPTION("Qualcomm Technologies, Inc. SCM driver");
-MODULE_LICENSE("GPL v2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/firmware/qcom_scm.h b/drivers/firmware/qcom_scm.h
index 0334f49d6655..100cf1108106 100644
--- a/drivers/firmware/qcom_scm.h
+++ b/drivers/firmware/qcom_scm.h
@@ -1,9 +1,12 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /* Copyright (c) 2010-2015,2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2025 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 #ifndef __QCOM_SCM_INT_H
 #define __QCOM_SCM_INT_H
 
+#include <linux/reset-controller.h>
+
 struct qcom_tzmem_pool;
 
 enum qcom_scm_convention {
@@ -62,6 +65,24 @@ struct qcom_scm_res {
 	u64 result[MAX_QCOM_SCM_RETS];
 };
 
+struct qcom_scm {
+	struct device *dev;
+	struct clk *core_clk;
+	struct clk *iface_clk;
+	struct clk *bus_clk;
+	struct icc_path *path;
+	struct completion waitq_comp;
+	struct reset_controller_dev reset;
+
+	/* control access to the interconnect path */
+	struct mutex scm_bw_lock;
+	int scm_vote_count;
+
+	u64 dload_mode_addr;
+
+	struct qcom_tzmem_pool *mempool;
+};
+
 int qcom_scm_wait_for_wq_completion(u32 wq_ctx);
 int scm_get_wq_ctx(u32 *wq_ctx, u32 *flags, u32 *more_pending);
 
@@ -81,6 +102,15 @@ extern int scm_legacy_call(struct device *dev, const struct qcom_scm_desc *desc,
 
 struct qcom_tzmem_pool *qcom_scm_get_tzmem_pool(void);
 
+extern struct qcom_scm *__scm;
+extern int qcom_scm_call(struct device *dev, const struct qcom_scm_desc *desc,
+			 struct qcom_scm_res *res);
+extern bool __qcom_scm_is_call_available(struct device *dev, u32 svc_id,
+					 u32 cmd_id);
+extern int qcom_scm_call_atomic(struct device *dev,
+				const struct qcom_scm_desc *desc,
+				struct qcom_scm_res *res);
+
 #define QCOM_SCM_SVC_BOOT		0x01
 #define QCOM_SCM_BOOT_SET_ADDR		0x01
 #define QCOM_SCM_BOOT_TERMINATE_PC	0x02
diff --git a/drivers/firmware/qcom_scm_addon.c b/drivers/firmware/qcom_scm_addon.c
index ca53ed8ce809..675224bec966 100644
--- a/drivers/firmware/qcom_scm_addon.c
+++ b/drivers/firmware/qcom_scm_addon.c
@@ -1,7 +1,32 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2023-2025 Qualcomm Innovation Center, Inc. All rights reserved.
  */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/cleanup.h>
+#include <linux/completion.h>
+#include <linux/cpumask.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/dma-mapping.h>
+#include <linux/interconnect.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/firmware/qcom/qcom_scm.h>
+#include <linux/firmware/qcom/qcom_tzmem.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/clk.h>
+#include <linux/reset-controller.h>
+#include <linux/sizes.h>
+#include <linux/arm-smccc.h>
+
+#include "qcom_scm.h"
 
 #define QCOM_SCM_MP_CP_SMMU_APERTURE_ID         0x1b
 #define QCOM_SCM_CP_APERTURE_REG    0x0
@@ -563,3 +588,6 @@ int qcom_scm_spin_cpu(void)
 	return qcom_scm_call(__scm->dev, &desc, NULL);
 }
 EXPORT_SYMBOL_GPL(qcom_scm_spin_cpu);
+
+MODULE_DESCRIPTION("Qualcomm Technologies, Inc. SCM addon driver");
+MODULE_LICENSE("GPL");
-- 
2.34.1

