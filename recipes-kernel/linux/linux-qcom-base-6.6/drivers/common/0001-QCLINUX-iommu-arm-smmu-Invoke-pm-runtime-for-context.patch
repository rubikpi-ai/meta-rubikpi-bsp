From c1934c0ea70e81c5457f78b95dba27a291de310a Mon Sep 17 00:00:00 2001
From: Prakash Gupta <quic_guptap@quicinc.com>
Date: Wed, 2 Apr 2025 21:04:58 +0530
Subject: [PATCH 1/1] QCLINUX: iommu/arm-smmu: Invoke pm runtime for context
 fault

commit d4a44f0750bb ("iommu/arm-smmu: Invoke pm_runtime across the driver")
enabled pm-runtime for arm-smmu device. For devices which implement pm
domain, all register space access should be protected with pm runtime
hooks. This patch adds pm runtime hooks to fault handler.

Change-Id: I560923fd6b3837eebf7cc47aa635ba789ca4ff52
Signed-off-by: Pratyush Brahma <quic_pbrahma@quicinc.com>
Signed-off-by: Prakash Gupta <quic_guptap@quicinc.com>
Upstream-Status: Pending
---
 drivers/iommu/arm/arm-smmu/arm-smmu.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu.c b/drivers/iommu/arm/arm-smmu/arm-smmu.c
index d6d1a2a55cc0..bdcb1b2adf52 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu.c
@@ -398,6 +398,10 @@ static irqreturn_t arm_smmu_context_fault(int irq, void *dev)
 	int idx = smmu_domain->cfg.cbndx;
 	int ret;
 
+	ret = arm_smmu_rpm_get(smmu);
+	if (ret < 0)
+		return IRQ_NONE;
+
 	fsr = arm_smmu_cb_read(smmu, idx, ARM_SMMU_CB_FSR);
 	if (!(fsr & ARM_SMMU_FSR_FAULT))
 		return IRQ_NONE;
@@ -415,7 +419,11 @@ static irqreturn_t arm_smmu_context_fault(int irq, void *dev)
 			    fsr, iova, fsynr, cbfrsynra, idx);
 
 	arm_smmu_cb_write(smmu, idx, ARM_SMMU_CB_FSR, fsr);
-	return IRQ_HANDLED;
+
+	ret = IRQ_HANDLED;
+out_power_off:
+	arm_smmu_rpm_put(smmu);
+	return ret;
 }
 
 static irqreturn_t arm_smmu_global_fault(int irq, void *dev)
@@ -424,6 +432,11 @@ static irqreturn_t arm_smmu_global_fault(int irq, void *dev)
 	struct arm_smmu_device *smmu = dev;
 	static DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,
 				      DEFAULT_RATELIMIT_BURST);
+	int ret;
+
+	ret = arm_smmu_rpm_get(smmu);
+	if (ret < 0)
+		return IRQ_NONE;
 
 	gfsr = arm_smmu_gr0_read(smmu, ARM_SMMU_GR0_sGFSR);
 	gfsynr0 = arm_smmu_gr0_read(smmu, ARM_SMMU_GR0_sGFSYNR0);
@@ -448,6 +461,7 @@ static irqreturn_t arm_smmu_global_fault(int irq, void *dev)
 	}
 
 	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_sGFSR, gfsr);
+	arm_smmu_rpm_put(smmu);
 	return IRQ_HANDLED;
 }
 
-- 
2.34.1

