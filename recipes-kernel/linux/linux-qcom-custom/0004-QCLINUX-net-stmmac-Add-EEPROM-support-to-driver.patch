From 996875d2acaaa28722a5be6a057cfbe8297e3a0d Mon Sep 17 00:00:00 2001
From: Vishal Kumar Pal <quic_vispal@quicinc.com>
Date: Sat, 28 Jun 2025 02:53:05 +0530
Subject: [PATCH] QCLINUX: net: stmmac: Add EEPROM support to driver

Add support for EEPROM in the stmmac driver. It enables reading
from and writing to EEPROM.

Change-Id: I6f35dbe7dccc59b4eaf1d650b7a764412532f277
Signed-off-by: Vishal Kumar Pal <quic_vispal@quicinc.com>
Upstream-Status: Pending

---
 .../stmicro/stmmac/dwmac-qcom-ethqos.c        | 65 +++++++++++++++++++
 .../ethernet/stmicro/stmmac/stmmac_platform.c | 12 ++++
 include/linux/stmmac.h                        |  2 +
 3 files changed, 79 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c
index 07dc7aa2c3ca..7698227c5bad 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c
@@ -8,10 +8,14 @@
 #include <linux/phy.h>
 #include <linux/phy/phy.h>
 #include <linux/pcs-xpcs-qcom.h>
+#include <linux/i2c.h>
 
 #include "stmmac.h"
 #include "stmmac_platform.h"
 
+#define EEPROM_STMMAC_READ_BYTE	17
+#define EEPROM_STMMAC_WRITE_OFFSET_BYTE	2
+
 #define RGMII_IO_MACRO_CONFIG		0x0
 #define SDCC_HC_REG_DLL_CONFIG		0x4
 #define SDCC_TEST_CTL			0x8
@@ -1053,6 +1057,64 @@ static void ethqos_xpcs_safety_stats(struct stmmac_priv *priv, unsigned long *pt
 		qcom_xpcs_get_err_stats(priv->hw->phylink_pcs, ptr);
 }
 
+static int ethqos_eeprom_readmac(struct plat_stmmacenet_data *plat_dat, struct device *dev,
+	 u8 *mac_addr)
+{
+	u8 wr_data[EEPROM_STMMAC_WRITE_OFFSET_BYTE] = {0, 0};
+	u8 rd_data[EEPROM_STMMAC_READ_BYTE];
+	struct i2c_adapter *adapter;
+	int mac_id = 0, j = 0, ret;
+	struct i2c_msg msg[2];
+	char *token = NULL;
+	u8 addr[ETH_ALEN];
+	char *temp_mac_addr;
+
+	adapter = i2c_get_adapter(plat_dat->i2c_id);
+	if (!adapter) {
+		/* error, no such I2C adaptor. */
+		dev_err(dev, "Chip at i2c Invalid i2c adapter %d\n", plat_dat->i2c_id);
+		return -ENODEV;
+	}
+
+	msg[0].addr = plat_dat->eeprom_reg;
+	msg[0].len = EEPROM_STMMAC_WRITE_OFFSET_BYTE;
+	msg[0].flags = 0;
+	msg[0].buf = wr_data;
+
+	msg[1].addr = plat_dat->eeprom_reg;
+	msg[1].len = EEPROM_STMMAC_READ_BYTE;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = rd_data;
+
+	ret = i2c_transfer(adapter, msg, 2);
+	if (ret != 2) {
+		dev_err(dev, "EEPROM I2C wrong response\n");
+		return ret;
+	} else {
+		temp_mac_addr = kmalloc(EEPROM_STMMAC_READ_BYTE, GFP_KERNEL);
+		if (!temp_mac_addr) {
+			dev_err(dev, "Memory allocation failed\n");
+			return -ENOMEM;
+		}
+
+		memcpy(temp_mac_addr, rd_data, EEPROM_STMMAC_READ_BYTE);
+		token = strsep(&temp_mac_addr, ":");
+		while (token) {
+			sscanf(token, "%x", &mac_id);
+			addr[j++] = mac_id;
+			token = strsep(&temp_mac_addr, ":");
+		}
+
+		if (is_valid_ether_addr(addr))
+			memcpy(mac_addr, addr, ETH_ALEN);
+		else
+			dev_err(dev, "invalid mac address from EEPROM\n");
+
+		kfree(temp_mac_addr);
+	}
+	return 0;
+}
+
 static int qcom_ethqos_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node, *root;
@@ -1193,6 +1255,9 @@ static int qcom_ethqos_probe(struct platform_device *pdev)
 		plat_dat->serdes_powerdown  = qcom_ethqos_serdes_powerdown;
 	}
 
+	if (plat_dat->eeprom_reg)
+		ethqos_eeprom_readmac(plat_dat, dev, stmmac_res.mac);
+
 	/* Enable TSO on queue0 and enable TBS on rest of the queues */
 	for (i = 1; i < plat_dat->tx_queues_to_use; i++)
 		plat_dat->tx_queues_cfg[i].tbs_en = 1;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index 2ee942d13d39..8e0ec3191519 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -422,6 +422,7 @@ stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 	int phy_mode;
 	void *ret;
 	int rc;
+	struct device_node *eeprom;
 
 	plat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);
 	if (!plat)
@@ -500,6 +501,17 @@ stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 	/* Set default value for unicast filter entries */
 	plat->unicast_filter_entries = 1;
 
+	plat->eeprom_reg = 0;
+	plat->i2c_id = 0;
+	eeprom = of_parse_phandle(np, "eeprom-for-mac", 0);
+	if (eeprom) {
+		if (of_property_read_u32(eeprom, "reg", &plat->eeprom_reg))
+			dev_err(&pdev->dev, "Failed to read eeprom_reg\n");
+
+		if (of_property_read_u32(eeprom, "i2c_id", &plat->i2c_id))
+			dev_err(&pdev->dev, "Failed to read i2c_id\n");
+	}
+
 	/*
 	 * Currently only the properties needed on SPEAr600
 	 * are provided. All other properties should be added
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index f18852b27a17..10c66485fdcc 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -344,5 +344,7 @@ struct plat_stmmacenet_data {
 	const struct dwmac4_addrs *dwmac4_addrs;
 	const struct dwxgmac_addrs *dwxgmac_addrs;
 	unsigned int flags;
+	u32 eeprom_reg;
+	u32 i2c_id;
 };
 #endif
-- 
2.25.1

