From 426fddc5a492fcb3c8922d83af3f768216f3242e Mon Sep 17 00:00:00 2001
From: Yifei Li <yifei.li_b@thundersoft.com>
Date: Wed, 9 Jul 2025 11:08:24 +0800
Subject: [PATCH] PFR sensor cdev node

Change-Id: Idaec0b31062baf0eeb755d11811f4e77987ce8cd
---
 .../cam_sensor/cam_sensor_core.c              | 129 ++++++++++++++++++
 1 file changed, 129 insertions(+)

diff --git a/camera_kt/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c b/camera_kt/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
index 913da41..fdb48ff 100644
--- a/camera_kt/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
+++ b/camera_kt/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
@@ -14,7 +14,91 @@
 #include "cam_packet_util.h"
 #include "cam_hdmi_bdg_core.h"
 #include "cam_dp_bdg_core.h"
+#include <linux/fs.h>
+
+// sensor node for userspace config 
+#define WRITE_PAIR_SIZE 4
+#define DEVICE_NAME "tof_sensor"
+#define PROBE_CAM1_SLOT_INDEX 7
+#define PROBE_CAM2_SLOT_INDEX 0
+#define CHAR_BUF_LEN 64
+#define CHAR_BUF_LEN_LONG 512  
+static int camera_probe_init_flag = -1;
+static dev_t tof_sensor_dev_t;
+static struct i2c_client *target_client;
+static struct cdev tof_sensor_dev;
+static struct class *tof_sensor_device_class;
+
+static uint32_t tof_slave_addr = 0x35;
+
+static int tof_sensor_open(struct inode *inode, struct file *file)
+{
+	CAM_DBG(CAM_SENSOR, "ToF sensor i2c config opened");
+    return 0;
+}
 
+static int tof_sensor_release(struct inode *inode, struct file *file)
+{
+	CAM_DBG(CAM_SENSOR, "ToF sensor i2c config closed");
+    return 0;
+}
+
+static ssize_t tof_sensor_write(struct file *file, const char __user *buf,
+                                 size_t count, loff_t *ppos)
+{
+    int ret;
+    u8 *tx_buf;
+    struct i2c_msg msg;
+    
+    if (!target_client)
+        return -ENODEV;
+        
+    if (count % WRITE_PAIR_SIZE != 0)
+        return -EINVAL;
+    
+    tx_buf = kmalloc(count, GFP_KERNEL);
+    if (!tx_buf)
+        return -ENOMEM;
+    
+    if (copy_from_user(tx_buf, buf, count)) {
+        ret = -EFAULT;
+        goto out_free;
+    }
+    
+    for (size_t i = 0; i < count; i += WRITE_PAIR_SIZE) {
+        u8 data[4] = {
+            tx_buf[i+1],   // Addr low
+            tx_buf[i],     // Addr high
+            tx_buf[i+3],    // Val low
+            tx_buf[i+2]   // Val high
+        };
+        
+        msg.addr = tof_slave_addr >> 1;
+        msg.flags = 0;
+        msg.len = sizeof(data);
+        msg.buf = data;
+        
+        ret = i2c_transfer(target_client->adapter, &msg, 1);
+        if (ret != 1) {
+            CAM_ERR(CAM_SENSOR, "I2C transfer failed, addr = 0x%02x%02x", tx_buf[i+1], tx_buf[i]);
+            ret = -EIO;
+            goto out_free;
+        }
+    }
+    
+    ret = count;
+    
+out_free:
+    kfree(tx_buf);
+    return ret;
+}
+
+static const struct file_operations tof_sensor_fops = {
+    .owner = THIS_MODULE,
+    .open = tof_sensor_open,
+    .release = tof_sensor_release,
+    .write = tof_sensor_write,
+};
 
 static int cam_sensor_update_req_mgr(
 	struct cam_sensor_ctrl_t *s_ctrl,
@@ -410,6 +494,7 @@ static int32_t cam_sensor_update_i2c_info(struct cam_cmd_i2c_info *i2c_info,
 	if (isInit) {
 		s_ctrl->sensordata->slave_info.sensor_slave_addr =
 			i2c_info->slave_addr;
+		tof_slave_addr = i2c_info->slave_addr;
 		s_ctrl->sensordata->slave_info.i2c_freq_mode =
 			i2c_info->i2c_freq_mode;
 	}
@@ -839,6 +924,50 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 	mutex_lock(&(s_ctrl->cam_sensor_mutex));
 	switch (cmd->op_code) {
 	case CAM_SENSOR_PROBE_CMD: {
+		if((camera_probe_init_flag == -1) && 
+			((s_ctrl->soc_info.index == PROBE_CAM1_SLOT_INDEX) || (s_ctrl->soc_info.index == PROBE_CAM2_SLOT_INDEX))){
+			CAM_INFO(CAM_SENSOR,"ToF sensor write device register Begin.");
+
+			rc = alloc_chrdev_region(&tof_sensor_dev_t, 0, 1, DEVICE_NAME);
+			if (rc) {
+				CAM_ERR(CAM_SENSOR, "Failed to allocate device number");
+				goto release_mutex;
+			}
+
+			cdev_init(&tof_sensor_dev, &tof_sensor_fops);
+			tof_sensor_dev.owner = THIS_MODULE;
+
+			rc = cdev_add(&tof_sensor_dev, MKDEV(MAJOR(tof_sensor_dev_t), MINOR(tof_sensor_dev_t) + 0), 1);
+			if (rc) {
+				CAM_ERR(CAM_SENSOR, "Failed to add device");
+				unregister_chrdev_region(tof_sensor_dev_t, 1);
+				goto release_mutex;
+			}
+
+			tof_sensor_device_class = class_create(DEVICE_NAME);
+			if (IS_ERR(tof_sensor_device_class)) {
+				CAM_ERR(CAM_SENSOR, "Failed to create device class");
+				cdev_del(&tof_sensor_dev);
+				unregister_chrdev_region(tof_sensor_dev_t, 1);
+				rc = PTR_ERR(tof_sensor_device_class);
+				goto release_mutex;
+			}
+
+			rc = device_create(tof_sensor_device_class, NULL, MKDEV(MAJOR(tof_sensor_dev_t), MINOR(tof_sensor_dev_t) + 0), NULL, DEVICE_NAME);
+			if (IS_ERR(rc)) {
+				CAM_ERR(CAM_SENSOR,"ToF sensor write device register Failed.");
+				class_destroy(tof_sensor_device_class);
+				cdev_del(&tof_sensor_dev);
+				unregister_chrdev_region(tof_sensor_dev_t, 1);
+				goto release_mutex;
+			} else {
+				target_client = s_ctrl->io_master_info.client;
+				CAM_INFO(CAM_SENSOR,"ToF sensor write device register End.");
+			}
+			
+			camera_probe_init_flag = 0;
+		}
+
 		if (s_ctrl->is_probe_succeed == 1) {
 			CAM_ERR(CAM_SENSOR,
 				"Already Sensor Probed in the slot");
-- 
2.17.1

